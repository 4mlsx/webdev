(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[201], { 5450: () => { }, 6440: e => { e.exports = { style: { fontFamily: "'Inter', 'Inter Fallback'", fontStyle: "normal" }, className: "__className_d65c78", variable: "__variable_d65c78" } }, 3901: (e, t, r) => { "use strict"; var n = r(2183).__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; t.c = function(e) { return n.H.useMemoCache(e) } }, 3193: (e, t, r) => { "use strict"; e.exports = r(3901) }, 9194: (e, t, r) => { "use strict"; r.d(t, { Kq: () => C }); var n = r(2183); let l = (e, t) => e.unstable_is ? e.unstable_is(t) : t === e, a = e => "init" in e, o = e => !!e.write, s = new WeakMap, i = e => { var t; return c(e) && !(null == (t = s.get(e)) ? void 0 : t[1]) }, d = (e, t) => { let r = s.get(e); if (r) r[1] = !0, r[0].forEach(e => e(t)); else throw Error("[Bug] cancelable promise not found") }, u = e => { if (s.has(e)) return; let t = [new Set, !1]; s.set(e, t); let r = () => { t[1] = !0 }; e.then(r, r), e.onCancel = e => { t[0].add(e) } }, c = e => "function" == typeof (null == e ? void 0 : e.then), m = e => "v" in e || "e" in e, f = e => { if ("e" in e) throw e.e; if (!("v" in e)) throw Error("[Bug] atom state is not initialized"); return e.v }, h = (e, t, r) => { r.p.has(e) || (r.p.add(e), t.then(() => { r.p.delete(e) }, () => { r.p.delete(e) })) }, v = (e, t, r, n, l) => { var a; if (n === t) throw Error("[Bug] atom cannot depend on itself"); r.d.set(n, l.n), i(r.v) && h(t, r.v, l), null == (a = l.m) || a.t.add(t), e && p(e, n, t) }, y = () => [new Map, new Map, new Set], w = (e, t, r) => { e[0].has(t) || e[0].set(t, new Set), e[1].set(t, r) }, p = (e, t, r) => { let n = e[0].get(t); n && n.add(r) }, g = (e, t) => e[0].get(t), b = (e, t) => { e[2].add(t) }, S = e => { let t; let r = !1, n = e => { try { e() } catch (e) { r || (t = e, r = !0) } }; for (; e[1].size || e[2].size;) { e[0].clear(); let t = new Set(e[1].values()); e[1].clear(); let r = new Set(e[2]); e[2].clear(), t.forEach(e => { var t; return null == (t = e.m) ? void 0 : t.l.forEach(n) }), r.forEach(n) } if (r) throw t }, _ = (...[e, t, r, n]) => { let s; s = new Set; let p = (t, r, n) => { let l = "v" in r, a = r.v, o = i(r.v) ? r.v : null; if (c(n)) { for (let l of (u(n), r.d.keys())) h(t, n, e(l)); r.v = n, delete r.e } else r.v = n, delete r.e; l && Object.is(a, r.v) || (++r.n, o && d(o, n)) }, E = (r, n, s) => { var i; let d, u; let h = e(n); if (m(h) && (h.m && !(null == s ? void 0 : s.has(n)) || Array.from(h.d).every(([e, t]) => E(r, e, s).n === t))) return h; h.d.clear(); let w = !0; try { let g = t(n, t => { if (l(n, t)) { let r = e(t); if (!m(r)) { if (a(t)) p(t, r, t.init); else throw Error("no atom init") } return f(r) } let o = E(r, t, s); try { return f(o) } finally { if (w) v(r, n, h, t, o); else { let e = y(); v(e, n, h, t, o), N(e, n, h), S(e) } } }, { get signal() { return d || (d = new AbortController), d.signal }, get setSelf() { return o(n) || console.warn("setSelf function cannot be used with read-only atom"), !u && o(n) && (u = (...e) => { if (w && console.warn("setSelf function cannot be called in sync"), !w) return A(n, ...e) }), u } }); if (p(n, h, g), c(g)) { null == (i = g.onCancel) || i.call(g, () => null == d ? void 0 : d.abort()); let e = () => { if (h.m) { let e = y(); N(e, n, h), S(e) } }; g.then(e, e) } return h } catch (e) { return delete h.v, h.e = e, ++h.n, h } finally { w = !1 } }, k = (t, r, n) => { var l, a; let o = new Map; for (let t of (null == (l = n.m) ? void 0 : l.t) || []) { let r = e(t); r.m && o.set(t, r) } for (let t of n.p) o.set(t, e(t)); return null == (a = g(t, r)) || a.forEach(t => { o.set(t, e(t)) }), o }, C = (e, t, r) => { let [n, l] = function(e, t, r) { let n = [], l = new Set, a = new Set, o = [[t, r]]; for (; o.length > 0;) { let [t, r] = o[o.length - 1]; if (a.has(t)) { o.pop(); continue } if (l.has(t)) { n.push([t, r, r.n]), a.add(t), o.pop(); continue } for (let [n, a] of (l.add(t), k(e, t, r))) t === n || l.has(n) || o.push([n, a]) } return [n, a] }(e, t, r), a = new Set([t]); for (let t = n.length - 1; t >= 0; --t) { let [r, o, s] = n[t], i = !1; for (let e of o.d.keys()) if (e !== r && a.has(e)) { i = !0; break } i && (E(e, r, l), N(e, r, o), s !== o.n && (w(e, r, o), a.add(r))), l.delete(r) } }, T = (t, n, ...o) => { let s = !0; try { return r(n, e => f(E(t, e)), (r, ...o) => { let i = e(r); try { if (!l(n, r)) return T(t, r, ...o); { if (!a(r)) throw Error("atom not writable"); let e = i.n, n = o[0]; p(r, i, n), N(t, r, i), e !== i.n && (w(t, r, i), C(t, r, i)); return } } finally { s || S(t) } }, ...o) } finally { s = !1 } }, A = (e, ...t) => { let r = y(); try { return T(r, e, ...t) } finally { S(r) } }, N = (t, r, n) => { if (n.m && !i(n.v)) { for (let l of n.d.keys()) n.m.d.has(l) || (M(t, l, e(l)).t.add(r), n.m.d.add(l)); for (let l of n.m.d || []) if (!n.d.has(l)) { n.m.d.delete(l); let a = L(t, l, e(l)); null == a || a.t.delete(r) } } }, M = (t, r, l) => { if (!l.m) { for (let n of (E(t, r), l.d.keys())) M(t, n, e(n)).t.add(r); if (l.m = { l: new Set, d: new Set(l.d.keys()), t: new Set }, s.add(r), o(r)) { let e; let a = l.m, o = (t, n) => { let l = !0; e = (...e) => { try { return T(t, r, ...e) } finally { l || S(t) } }; try { return n() } finally { l = !1 } }; b(t, () => { let l = o(t, () => n(r, (...t) => e(...t))); l && (a.u = e => o(e, l)) }) } } return l.m }, L = (t, r, n) => { if (n.m && !n.m.l.size && !Array.from(n.m.t).some(t => { var n; return null == (n = e(t).m) ? void 0 : n.d.has(r) })) { let l = n.m.u; for (let a of (l && b(t, () => l(t)), delete n.m, s.delete(r), n.d.keys())) { let n = L(t, a, e(a)); null == n || n.t.delete(r) } return } return n.m }, O = { get: e => f(E(void 0, e)), set: A, sub: (t, r) => { let n = y(), l = e(t), a = M(n, t, l).l; return a.add(r), S(n), () => { a.delete(r); let e = y(); L(e, t, l), S(e) } }, unstable_derive: l => _(...l(e, t, r, n)) }; return Object.assign(O, { dev4_get_internal_weak_map: () => ({ get: t => { let r = e(t); if (0 !== r.n) return r } }), dev4_get_mounted_atoms: () => s, dev4_restore_atoms: t => { let r = y(); for (let [n, l] of t) if (a(n)) { let t = e(n), a = t.n; p(n, t, l), N(r, n, t), a !== t.n && (w(r, n, t), C(r, n, t)) } S(r) } }), O }, E = () => { let e = new WeakMap; return _(t => { if (!t) throw Error("Atom is undefined or null"); let r = e.get(t); return r || (r = { d: new Map, p: new Set, n: 0 }, e.set(t, r)), r }, (e, ...t) => e.read(...t), (e, ...t) => e.write(...t), (e, ...t) => { var r; return null == (r = e.onMount) ? void 0 : r.call(e, ...t) }) }, k = (0, n.createContext)(void 0), C = e => { let { children: t, store: r } = e, l = (0, n.useRef)(void 0); return r || l.current || (l.current = E()), (0, n.createElement)(k.Provider, { value: r || l.current }, t) }, T = e => { e.status = "pending", e.then(t => { e.status = "fulfilled", e.value = t }, t => { e.status = "rejected", e.reason = t }) }; n.use || (e => { if ("pending" === e.status) throw e; if ("fulfilled" === e.status) return e.value; if ("rejected" === e.status) throw e.reason; throw T(e), e }) }, 8770: (e, t, r) => { "use strict"; r.d(t, { N: () => d }); var n = r(2183), l = (e, t, r, n, l, a, o, s) => { let i = document.documentElement, d = ["light", "dark"]; function u(t) { (Array.isArray(e) ? e : [e]).forEach(e => { let r = "class" === e, n = r && a ? l.map(e => a[e] || e) : l; r ? (i.classList.remove(...n), i.classList.add(t)) : i.setAttribute(e, t) }), s && d.includes(t) && (i.style.colorScheme = t) } if (n) u(n); else try { let e = localStorage.getItem(t) || r, n = o && "system" === e ? window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : e; u(n) } catch (e) { } }, a = ["light", "dark"], o = "(prefers-color-scheme: dark)", s = "undefined" == typeof window, i = n.createContext(void 0), d = e => n.useContext(i) ? n.createElement(n.Fragment, null, e.children) : n.createElement(c, { ...e }), u = ["light", "dark"], c = e => { let { forcedTheme: t, disableTransitionOnChange: r = !1, enableSystem: l = !0, enableColorScheme: s = !0, storageKey: d = "theme", themes: c = u, defaultTheme: y = l ? "system" : "light", attribute: w = "data-theme", value: p, children: g, nonce: b, scriptProps: S } = e, [_, E] = n.useState(() => f(d, y)), [k, C] = n.useState(() => f(d)), T = p ? Object.values(p) : c, A = n.useCallback(e => { let t = e; if (!t) return; "system" === e && l && (t = v()); let n = p ? p[t] : t, o = r ? h(b) : null, i = document.documentElement, d = e => { "class" === e ? (i.classList.remove(...T), n && i.classList.add(n)) : e.startsWith("data-") && (n ? i.setAttribute(e, n) : i.removeAttribute(e)) }; if (Array.isArray(w) ? w.forEach(d) : d(w), s) { let e = a.includes(y) ? y : null, r = a.includes(t) ? t : e; i.style.colorScheme = r } null == o || o() }, [b]), N = n.useCallback(e => { let t = "function" == typeof e ? e(_) : e; E(t); try { localStorage.setItem(d, t) } catch (e) { } }, [_]), M = n.useCallback(e => { C(v(e)), "system" === _ && l && !t && A("system") }, [_, t]); n.useEffect(() => { let e = window.matchMedia(o); return e.addListener(M), M(e), () => e.removeListener(M) }, [M]), n.useEffect(() => { let e = e => { e.key === d && (e.newValue ? E(e.newValue) : N(y)) }; return window.addEventListener("storage", e), () => window.removeEventListener("storage", e) }, [N]), n.useEffect(() => { A(null != t ? t : _) }, [t, _]); let L = n.useMemo(() => ({ theme: _, setTheme: N, forcedTheme: t, resolvedTheme: "system" === _ ? k : _, themes: l ? [...c, "system"] : c, systemTheme: l ? k : void 0 }), [_, N, t, k, l, c]); return n.createElement(i.Provider, { value: L }, n.createElement(m, { forcedTheme: t, storageKey: d, attribute: w, enableSystem: l, enableColorScheme: s, defaultTheme: y, value: p, themes: c, nonce: b, scriptProps: S }), g) }, m = n.memo(e => { let { forcedTheme: t, storageKey: r, attribute: a, enableSystem: o, enableColorScheme: s, defaultTheme: i, value: d, themes: u, nonce: c, scriptProps: m } = e, f = JSON.stringify([a, r, i, t, u, d, o, s]).slice(1, -1); return n.createElement("script", { ...m, suppressHydrationWarning: !0, nonce: "undefined" == typeof window ? c : "", dangerouslySetInnerHTML: { __html: "(".concat(l.toString(), ")(").concat(f, ")") } }) }), f = (e, t) => { let r; if (!s) { try { r = localStorage.getItem(e) || void 0 } catch (e) { } return r || t } }, h = e => { let t = document.createElement("style"); return e && t.setAttribute("nonce", e), t.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(t), () => { window.getComputedStyle(document.body), setTimeout(() => { document.head.removeChild(t) }, 1) } }, v = e => (e || (e = window.matchMedia(o)), e.matches ? "dark" : "light") } }]);